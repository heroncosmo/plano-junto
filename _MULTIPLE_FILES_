import { supabase } from '@/integrations/supabase/client';

export interface MPayer {
  email: string;
  first_name?: string;
  last_name?: string;
  identification?: { type: 'CPF' | 'CNPJ'; number: string };
}

export async function createPixPaymentSupabase(params: {
  amountCents: number;
  description: string;
  payer: MPayer;
  externalReference?: string;
}) {
  const { data, error } = await supabase.functions.invoke('mercadopago-create', {
    body: { type: 'pix', ...params },
  });
  if (error) throw error;
  return data;
}

export async function getPaymentStatusSupabase(id: string) {
  const { data, error } = await supabase.functions.invoke('mercadopago-status', {
    headers: { 'Content-Type': 'application/json' },
    // Supabase invoke n√£o aceita querystring; passamos no body
    body: { id },
  });
  if (error) throw error;
  return data;
}

import 'jsr:@supabase/functions-js/edge-runtime.d.ts';
import { corsHeaders } from '../mercadopago-create/index.ts';

const MP_ACCESS_TOKEN = Deno.env.get('MP_ACCESS_TOKEN');

export default async function handler(req: Request): Promise<Response> {
  if (req.method === 'OPTIONS') return new Response('ok', { headers: corsHeaders });
  if (!MP_ACCESS_TOKEN) return new Response(JSON.stringify({ error: 'Missing MP_ACCESS_TOKEN' }), { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });

  const url = new URL(req.url);
  const id = url.searchParams.get('id');
  if (!id) return new Response(JSON.stringify({ error: 'Missing id' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });

  try {
    const resp = await fetch(`https://api.mercadopago.com/v1/payments/${id}`, {
      headers: { Authorization: `Bearer ${MP_ACCESS_TOKEN}` },
    });
    const data = await resp.json();
    if (!resp.ok) return new Response(JSON.stringify({ success: false, error: data }), { status: resp.status, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    return new Response(JSON.stringify({ success: true, payment: data }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
  } catch (e) {
    return new Response(JSON.stringify({ success: false, error: String(e) }), { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
  }
}

Deno.serve(handler);

import 'jsr:@supabase/functions-js/edge-runtime.d.ts';

export const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
};

const MP_ACCESS_TOKEN = Deno.env.get('MP_ACCESS_TOKEN');

export default async function handler(req: Request): Promise<Response> {
  if (req.method === 'OPTIONS') return new Response('ok', { headers: corsHeaders });
  if (!MP_ACCESS_TOKEN) return new Response(JSON.stringify({ error: 'Missing MP_ACCESS_TOKEN' }), { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });

  try {
    const body = await req.json();
    const { type, amountCents, description, payer, token, installments = 1, externalReference } = body || {};
    if (!type || !amountCents || !description || !payer) {
      return new Response(JSON.stringify({ error: 'Missing required fields' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    const transaction_amount = Math.round(Number(amountCents)) / 100;

    const payload: Record<string, unknown> = {
      transaction_amount,
      description,
      payer,
      external_reference: externalReference,
    };

    if (type === 'pix') {
      payload.payment_method_id = 'pix';
    } else if (type === 'card') {
      if (!token) return new Response(JSON.stringify({ error: 'Missing card token' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      payload.token = token;
      payload.installments = installments;
    }

    const resp = await fetch('https://api.mercadopago.com/v1/payments', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${MP_ACCESS_TOKEN}`,
      },
      body: JSON.stringify(payload),
    });

    const data = await resp.json();
    if (!resp.ok) {
      return new Response(JSON.stringify({ success: false, error: data }), { status: resp.status, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }
    return new Response(JSON.stringify({ success: true, payment: data }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
  } catch (e) {
    return new Response(JSON.stringify({ success: false, error: String(e) }), { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
  }
}

Deno.serve(handler);

-- Enable pgcrypto for encryption
create extension if not exists pgcrypto;

-- Table to store encrypted credentials
create table if not exists public.payment_credentials (
  id uuid primary key default gen_random_uuid(),
  provider text not null check (provider in ('mercadopago')),
  token_encrypted bytea not null,
  created_by uuid not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_payment_credentials_provider_created_at
  on public.payment_credentials(provider, created_at desc);

-- RLS deny-all
alter table public.payment_credentials enable row level security;
drop policy if exists payment_credentials_deny_all on public.payment_credentials;
create policy payment_credentials_deny_all on public.payment_credentials
  for all using (false) with check (false);

-- updated_at trigger
create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_payment_credentials_updated_at on public.payment_credentials;
create trigger trg_payment_credentials_updated_at
before update on public.payment_credentials
for each row execute procedure public.set_updated_at();

-- Write-only function (encrypt inside DB)
create or replace function public.save_payment_credential(
  p_provider text,
  p_token_plain text,
  p_master_key text
) returns void as $$
begin
  insert into public.payment_credentials(provider, token_encrypted, created_by)
  values (
    p_provider,
    pgp_sym_encrypt(p_token_plain, p_master_key),
    auth.uid()
  );
end;
$$ language plpgsql security definer;

-- Read function (decrypt latest)
create or replace function public.get_payment_credential(
  p_provider text,
  p_master_key text
) returns text as $$
declare
  v_token text;
begin
  select pgp_sym_decrypt(pc.token_encrypted, p_master_key)::text
  into v_token
  from public.payment_credentials pc
  where pc.provider = p_provider
  order by pc.created_at desc
  limit 1;
  return v_token;
end;
$$ language plpgsql security definer;


